<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF--8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hand & Elbow Drawing Board</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      height:100vh;display:flex;flex-direction:column;overflow:hidden
    }
    .header{background:rgba(0,0,0,.8);color:#fff;text-align:center;padding:10px;backdrop-filter:blur(10px)}
    .main-container{flex:1;position:relative;overflow:hidden; background-color: #000;}
    #videoContainer{position:absolute;inset:0;}
    #video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
    #drawingCanvas{position:absolute;inset:0;z-index:3}
    #taskCharacter{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      font-size: 35vw; font-weight: bold; color: rgba(255,255,255,0.15);
      z-index:2; pointer-events:none; user-select:none;
    }
    .controls{
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      display:flex;gap:12px;background:rgba(0,0,0,.8);padding:12px 16px;border-radius:22px;
      backdrop-filter:blur(10px);z-index:10;flex-wrap:wrap;justify-content:center
    }
    .control-btn{
      padding:10px 16px;border:none;border-radius:18px;cursor:pointer;font-weight:700;
      transition:.2s;display:flex;align-items:center;gap:8px;font-size:14px;color:#fff
    }
    .control-btn:hover{transform:translateY(-2px);box-shadow:0 5px 15px rgba(0,0,0,.3)}
    .clear-btn{background:linear-gradient(45deg,#ffa726,#ff9800)}
    .calibrate-btn{background:linear-gradient(45deg,#2196f3,#1976d2)}
    .refresh-btn{background:linear-gradient(45deg,#4caf50,#66bb6a)}
    .settings{
      position:absolute;top:20px;right:20px;background:rgba(0,0,0,.8);padding:14px;border-radius:14px;
      backdrop-filter:blur(10px);z-index:10;color:#fff;min-width:240px
    }
    .setting-item{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .setting-item:last-child{margin-bottom:0}
    .setting-item input[type="range"]{width:120px}
    .color-picker{width:36px;height:36px;border:none;border-radius:50%;cursor:pointer;background:transparent}
    .status{
      position:absolute;top:20px;left:20px;background:rgba(0,0,0,.8);color:#fff;padding:12px;border-radius:10px;backdrop-filter:blur(10px);z-index:10;min-width:280px
    }
    .score-board{
      position:absolute;top:90px;left:20px;background:rgba(0,0,0,.8);color:#fff;padding:12px;border-radius:10px;backdrop-filter:blur(10px);z-index:10;min-width:280px
    }
    .loading{
      position:absolute;inset:0;margin:auto;height:max-content;width:max-content;
      background:rgba(0,0,0,.9);color:#fff;padding:24px;border-radius:14px;z-index:20;text-align:center;display:none
    }
    .crosshair{
      position:absolute;width:28px;height:28px;border:2px solid #00ff00;border-radius:50%;
      transform:translate(-50%,-50%);pointer-events:none;z-index:5;opacity:0;transition:opacity .2s
    }
    .crosshair.active{opacity:1;box-shadow:0 0 20px rgba(0,255,0,.6)}
    .success-message {
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:50;
      background: linear-gradient(45deg, #4caf50, #81c784); color:#fff;
      padding: 20px 28px; border-radius:16px; font-weight:700; font-size: 2.2em;
      animation: successPop 2.5s ease-in-out forwards;
    }
    @keyframes successPop {
      0% { transform:translate(-50%,-50%) scale(0); opacity:0; }
      10% { transform:translate(-50%,-50%) scale(1.1); opacity:1; }
      90% { transform:translate(-50%,-50%) scale(1.0); opacity:1; }
      100% { transform:translate(-50%,-50%) scale(0.9); opacity:0; }
    }
  </style>
</head>
<body>
  <div class="header">
  <h1>Character Drawing Challenge</h1>
  </div>

  <div id="mainContainer" class="main-container">
    <div id="loading" class="loading">Loading...</div>
    <div id="videoContainer">
      <video id="video" autoplay muted playsinline></video>
      <div id="crosshair" class="crosshair"></div>
      <div id="taskCharacter">A</div>
    </div>
    <canvas id="drawingCanvas"></canvas>
  </div>

  <audio id="backgroundMusic" src="musicbg.mp3" loop preload="auto"></audio>

  <div class="controls">
    <button id="clearBtn" class="control-btn clear-btn">üóëÔ∏è Clear Drawing</button>
    <button id="refreshBtn" class="control-btn refresh-btn">üîÑ New Task</button>
    <button id="calibrateBtn" class="control-btn calibrate-btn">üéØ Recalibrate Pointer</button>
  </div>

  <div class="settings">
    <div class="setting-item">
      <label>Draw Color:</label>
      <input type="color" id="colorPicker" class="color-picker" value="#00ff00"/>
    </div>
    <div class="setting-item">
      <label>Brush Size:</label>
      <input type="range" id="brushSize" min="2" max="50" value="15"/>
      <span id="brushSizeValue">15</span>
    </div>
    <div class="setting-item">
      <label>Smoothing:</label>
      <input type="range" id="smoothing" min="0.05" max="0.9" step="0.05" value="0.35"/>
      <span id="smoothingValue">35%</span>
    </div>
  </div>

  <div id="status" class="status">Initializing...</div>
  <div class="score-board">
    <div><strong>Score:</strong> <span id="score">0</span></div>
    <div><strong>Last Match:</strong> <span id="matchPercentage">N/A</span></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

  <script>
  class BodyDrawingBoard {
    constructor(){
      // Core elements
      this.video = document.getElementById('video');
      this.drawingCanvas = document.getElementById('drawingCanvas');
      this.drawingCtx = this.drawingCanvas.getContext('2d');
      this.mainContainer = document.getElementById('mainContainer');
      this.crosshair = document.getElementById('crosshair');
      this.loading = document.getElementById('loading');
      this.status = document.getElementById('status');
      this.backgroundMusic = document.getElementById('backgroundMusic');
      
      // Game elements
      this.taskCharacterEl = document.getElementById('taskCharacter');
      this.scoreEl = document.getElementById('score');
      this.matchPercentageEl = document.getElementById('matchPercentage');
      
      // Controls
      this.clearBtn = document.getElementById('clearBtn');
      this.calibrateBtn = document.getElementById('calibrateBtn');
      this.refreshBtn = document.getElementById('refreshBtn');

      // Settings
      this.brushSizeSlider = document.getElementById('brushSize');
      this.brushSizeValue  = document.getElementById('brushSizeValue');
      this.colorPicker = document.getElementById('colorPicker');
      this.smoothingSlider = document.getElementById('smoothing');
      this.smoothingValue  = document.getElementById('smoothingValue');
      
      // State
      this.lastPoint = null;
      this.smoothed = {x:0, y:0};
      this.isDrawing = false;
      this.drawingPath = [];
      this.drawCheckTimeout = null;
      
      // Game State
      this.score = 0;
      this.currentTask = 'A';
      this.taskTemplates = this.createTaskTemplates();
      this.possibleTasks = Object.keys(this.taskTemplates);

      // Camera/ML state
      this.pose = null;
      this.camera = null;

      this.bindUI();
      this.initCameraSystem();
      window.addEventListener('resize', ()=>this.resizeCanvas());
    }

    bindUI(){
      this.clearBtn.addEventListener('click', () => this.clearDrawing());
      this.refreshBtn.addEventListener('click', () => this.generateNewTask());
      
      this.calibrateBtn.addEventListener('click', () => {
        this.lastPoint = null;
        this.smoothed = {x:0, y:0};
        this.setStatus('Pointer state recalibrated.');
      });

      this.brushSizeSlider.addEventListener('input', e => this.brushSizeValue.textContent = e.target.value);
      this.smoothingSlider.addEventListener('input', e => this.smoothingValue.textContent = `${Math.round(parseFloat(e.target.value)*100)}%`);
    }

    resizeCanvas(){
      this.drawingCanvas.width = this.mainContainer.clientWidth;
      this.drawingCanvas.height = this.mainContainer.clientHeight;
      this.clearDrawing();
    }
    
    // CAMERA & GESTURE LOGIC
    async initCameraSystem() {
      await this.initCamera();
      this.initPose();
      this.generateNewTask(); // Generate first task
    }
    
    async initCamera() {
      this.loading.style.display = 'block';
      this.loading.innerHTML = '<h3>Starting Camera...</h3><p>Please allow camera access</p>';
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720, facingMode: 'user' } });
        this.video.srcObject = stream;
        await new Promise(res => this.video.onloadedmetadata = res);
        this.resizeCanvas();
        this.loading.style.display = 'none';
        this.setStatus('Camera started successfully.');
        // Play background music once camera is active
        if(this.backgroundMusic) {
            this.backgroundMusic.play().catch(e => console.warn("Background music failed to play:", e));
        }
      } catch (err) {
        this.loading.innerHTML = `<h3 style="color:red">Camera Error</h3><p>${err.message}</p>`;
        this.setStatus('Camera permission denied.');
      }
    }

    initPose() {
      this.pose = new Pose({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}` });
      this.pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      this.pose.onResults(r => this.onPoseResults(r));
      
      this.camera = new Camera(this.video, { 
        onFrame: async () => { await this.pose.send({ image: this.video }); }, 
        width: 1280, 
        height: 720 
      });
      this.camera.start();
      this.setStatus('Pose detection model loaded.');
    }

    onPoseResults(results) {
      // Handle the timeout for checking the drawing when the user stops
      clearTimeout(this.drawCheckTimeout);
      this.drawCheckTimeout = setTimeout(() => {
        if (this.isDrawing) {
            this.checkDrawing();
            this.isDrawing = false;
        }
      }, 1500); // 1.5 second delay after stopping to check the drawing

      if (!results.poseLandmarks) {
        this.crosshair.classList.remove('active');
        this.lastPoint = null;
        return;
      }
      
      const lm = results.poseLandmarks;
      // *** THIS IS THE FIX ***
      // Correctly get the specific landmarks from the results array.
      const indexTip = lm[20]; // Right index finger
      const elbow = lm[14];     // Right elbow
      
      let activeLandmark = null;

      // Prioritize index finger, fall back to elbow
      if (indexTip && indexTip.visibility > 0.7) {
        activeLandmark = indexTip;
        this.setStatus("Drawing with: Right Hand");
      } else if (elbow && elbow.visibility > 0.8) {
        activeLandmark = elbow;
        this.setStatus("Drawing with: Right Elbow");
      }

      if (activeLandmark) {
        this.isDrawing = true;
        const pt = { 
            x: (1 - activeLandmark.x) * this.drawingCanvas.width, 
            y: activeLandmark.y * this.drawingCanvas.height 
        };

        const s = parseFloat(this.smoothingSlider.value);
        this.smoothed.x = this.lastPoint ? (this.smoothed.x * s + pt.x * (1 - s)) : pt.x;
        this.smoothed.y = this.lastPoint ? (this.smoothed.y * s + pt.y * (1 - s)) : pt.y;
        
        this.updateCrosshair(this.smoothed);
        this.drawAtPoint(this.smoothed);
        this.drawingPath.push({ ...this.smoothed });
        this.lastPoint = { ...this.smoothed };
      } else {
        this.crosshair.classList.remove('active');
        this.lastPoint = null; // Stop drawing if neither is visible
        this.setStatus("No valid drawing point detected.");
      }
    }

    drawAtPoint(p) {
      const size = parseInt(this.brushSizeSlider.value);
      const color = this.colorPicker.value;
      this.drawingCtx.strokeStyle = color;
      this.drawingCtx.lineWidth = size;
      this.drawingCtx.lineCap = 'round';

      if (this.lastPoint) {
        this.drawingCtx.beginPath();
        this.drawingCtx.moveTo(this.lastPoint.x, this.lastPoint.y);
        this.drawingCtx.lineTo(p.x, p.y);
        this.drawingCtx.stroke();
      }
    }
    
    updateCrosshair(p) {
      this.crosshair.style.left = `${p.x}px`;
      this.crosshair.style.top = `${p.y}px`;
      this.crosshair.classList.add('active');
    }
    
    setStatus(msg) { this.status.textContent = msg; }

    clearDrawing() {
        this.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
        this.lastPoint = null;
        this.drawingPath = [];
        this.setStatus('Canvas cleared!');
    }
    
    // --- GAME LOGIC ---

    generateNewTask() {
      const nextTask = this.possibleTasks[Math.floor(Math.random() * this.possibleTasks.length)];
      this.currentTask = nextTask;
      this.taskCharacterEl.textContent = this.currentTask;
      this.clearDrawing();
      this.matchPercentageEl.textContent = 'N/A';
    }

    checkDrawing() {
        if (!this.drawingPath.length || !this.currentTask) return;

        const template = this.taskTemplates[this.currentTask];
        const w = this.drawingCanvas.width;
        const h = this.drawingCanvas.height;

        // Scale template points to canvas size
        const scaledTemplate = template.points.map(p => ({ x: p.x * w, y: p.y * h }));

        const threshold = template.threshold * Math.min(w, h);
        const checkedTemplatePoints = new Set();

        // Check how many of the template's key points were "hit" by the drawing
        for (const templatePoint of scaledTemplate) {
            for (const drawnPoint of this.drawingPath) {
                const dx = drawnPoint.x - templatePoint.x;
                const dy = drawnPoint.y - templatePoint.y;
                if (Math.sqrt(dx * dx + dy * dy) < threshold) {
                    checkedTemplatePoints.add(templatePoint);
                    break; // Move to the next template point once this one is hit
                }
            }
        }
        
        const matchPercentage = (checkedTemplatePoints.size / scaledTemplate.length) * 100;
        this.matchPercentageEl.textContent = `${matchPercentage.toFixed(1)}%`;

        if (matchPercentage > 70) {
            const points = Math.round(matchPercentage);
            this.score += points;
            this.scoreEl.textContent = this.score;
            this.showSuccess(`+${points} Points!`);
            setTimeout(() => this.generateNewTask(), 2000);
        } else {
            this.setStatus("Not quite, try that letter again!");
        }
    }
    
    showSuccess(text) {
        const el = document.createElement('div');
        el.className = 'success-message';
        el.textContent = text;
        this.mainContainer.appendChild(el);
        setTimeout(() => el.remove(), 2400);
    }
    
    // Defines the shapes for the drawing tasks
    createTaskTemplates() {
        // Points are normalized (0 to 1). X=0 is left, Y=0 is top.
        // A larger threshold is needed for shapes with fewer points.
        return {
            'A': {
                threshold: 0.1, points: [
                    {x:0.5,y:0.2},{x:0.3,y:0.8},{x:0.7,y:0.8},{x:0.4,y:0.6},{x:0.6,y:0.6},{x:0.5,y:0.22},
                    {x:0.35,y:0.7},{x:0.65,y:0.7},{x:0.45,y:0.4},{x:0.55,y:0.4}
                ]
            },
            'C': {
                threshold: 0.1, points: [
                    {x:0.6,y:0.25},{x:0.4,y:0.3},{x:0.35,y:0.5},{x:0.4,y:0.7},{x:0.6,y:0.75},
                    {x:0.5,y:0.22},{x:0.32,y:0.6},{x:0.5,y:0.78}
                ]
            },
            'L': {
                threshold: 0.12, points: [
                    {x:0.35,y:0.2},{x:0.35,y:0.5},{x:0.35,y:0.8},{x:0.45,y:0.8},{x:0.55,y:0.8},{x:0.65,y:0.8}
                ]
            },
            'T': {
                threshold: 0.12, points: [
                    {x:0.3,y:0.25},{x:0.4,y:0.25},{x:0.5,y:0.25},{x:0.6,y:0.25},{x:0.7,y:0.25},
                    {x:0.5,y:0.4},{x:0.5,y:0.6},{x:0.5,y:0.8}
                ]
            },
            'O': {
                threshold: 0.08, points: [
                    {x:0.5,y:0.2},{x:0.35,y:0.3},{x:0.3,y:0.5},{x:0.35,y:0.7},{x:0.5,y:0.8},
                    {x:0.65,y:0.7},{x:0.7,y:0.5},{x:0.65,y:0.3}
                ]
            },
            '1': {
                threshold: 0.15, points: [
                    {x:0.5,y:0.2},{x:0.5,y:0.4},{x:0.5,y:0.6},{x:0.5,y:0.8},{x:0.4,y:0.3}
                ]
            },
            '7': {
                threshold: 0.12, points: [
                    {x:0.3,y:0.25},{x:0.5,y:0.25},{x:0.7,y:0.25},{x:0.6,y:0.5},{x:0.5,y:0.8}
                ]
            }
        };
    }
  }

  window.addEventListener('DOMContentLoaded', () => new BodyDrawingBoard());
  </script>
</body>
</html>